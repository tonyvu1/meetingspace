<header>
  <% include partials/nav.ejs %>
</header>

<body>

  <div class="col-12 mt-2" id="classroom-container">

      <div class="row justify-content-center">
       
          <video class="col-7 mr-3" id="remoteVideo" autoplay>sdf</video>

   
          <div class="col-4" id="chat-wrapper">
              <div
                class="col-md-11"
                id="chat-body"
              >
                <div class="panel panel-primary">
                  <div class="panel-heading text-center">
                    <span class="glyphicon glyphicon-comment"></span>
                    <strong>Messages</strong>
                  </div>
                  <div class="panel-body body-panel">
                    <ul class="chat"></ul>
                  </div>
                  <div class="panel-footer clearfix">
                    <input id="message" class="form-control" type="text" disabled />
                    <span
                      class="col-lg-6 col-lg-offset-3 col-md-6 col-md-offset-3 col-xs-12"
                      style="margin-top: 10px"
                    >
                      <button class="btn btn-warning btn-lg btn-block" id="btn-chat">
                        Send
                      </button>
                    </span>
                  </div>
                </div>
              </div>
              <video id="localVideo" autoplay class="col-md-11 mt-3"></video>
            </div>
    

      </div>
    </div>
    





  

  <script
    type="text/javascript"
    src="https://cdn.scaledrone.com/scaledrone.min.js"
  ></script>
  <script src="https://media.twiliocdn.com/sdk/js/chat/v1.1/twilio-chat.min.js"></script>
  <script src="/style/jquery/dist/jquery.js"></script>
</body>

<style>

html {
  overflow-y: hidden;
}
  #classroom-container {
    height: 100vh;
    justify-content: center;
  }

  #chat-body {
    border: 1px solid rgb(165, 165, 165);
   

    box-shadow: rgba(156, 172, 172, 0.2) 0px 2px 2px,
      rgba(156, 172, 172, 0.2) 0px 4px 4px, rgba(156, 172, 172, 0.2) 0px 8px 8px,
      rgba(156, 172, 172, 0.2) 0px 16px 16px,
      rgba(156, 172, 172, 0.2) 0px 32px 32px,
      rgba(156, 172, 172, 0.2) 0px 64px 64px;
  }

  .chat {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .chat li {
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px dotted #b3a9a9;
  }

  .chat li .chat-body p {
    margin: 0;
    color: #777777;
  }

  .body-panel {
    overflow-y: scroll;
    height: 250px;
  }

  video {
    box-shadow: rgba(156, 172, 172, 0.2) 0px 2px 2px,
      rgba(156, 172, 172, 0.2) 0px 4px 4px, rgba(156, 172, 172, 0.2) 0px 8px 8px,
      rgba(156, 172, 172, 0.2) 0px 16px 16px,
      rgba(156, 172, 172, 0.2) 0px 32px 32px,
      rgba(156, 172, 172, 0.2) 0px 64px 64px;
  }
</style>

<script id="new-message" type="text/template">
  <li id="{{id}}" class="right clearfix">
      <div class="chat-body clearfix">
          <p>
              {{body}}
          </p>
      </div>
  </li>
</script>

<script>
  $(document).ready(function() {
    let username = "tony";
    let chatChannel;

    getToken()
      .then(token => {
        console.log("returned token is ", token);
        return Twilio.Chat.Client.create(token, { logLevel: "debug" });
      })
      .then(client => {


        getChannelDescriptor(client)
          .then(channel => client.getChannelByUniqueName("chat34channel"))
          .then(channel => channel.join())
          .then(channel => {
            chatSetupCompleted();
            chatChannel = channel;
            channel.on("messageAdded", onMessageAdded);
            activateChatBox();
          });
      })
      .catch(
        error =>
          console.log("error setting up twilio", error) || chatSetupFailed()
      );

    function getToken() {
      return fetch(`/token?username=${username}`)
        .then(response => {
          if (response.ok) {
            return response.text();
          }

          throw new Error("Network response was not ok.");
        })
        .catch(error => console.log("Error fetching token", error) || error);
    }

     function getChannelDescriptor(chatClient) {
      return chatClient
        .getPublicChannelDescriptors()
        .then(function(paginator) {
          if (paginator.items.length > 0) return paginator.items[0];
          else {
            chatClient
              .createChannel({
                uniqueName: "chat3channel",
                friendlyName: "chat3channel",
                isPrivate: false
              })
              .then(function(newChannel) {
                console.log("Created general channel:");
                console.log(newChannel);
                return newChannel;
              });
          }
        })
        .then(channel => channel)
        .catch(error => console.log("error getting channel", error) || error);
    } 

    /*
     .getChannelByUniqueName("chat3channel")
        .then(channel => channel)
        .catch(error => console.log("error getting channel", error) || error);

    */
    
    function onMessageAdded(message) {
      let template = $("#new-message").html();
      template = template.replace(
        "{{body}}",
        `<b>${message.author}:</b> ${message.body}`
      );

      $(".chat").append(template);
    }

    function chatSetupCompleted() {
      let template = $("#new-message").html();
      template = template.replace(
        "{{body}}",
        "<b>Welcome to class!</b>"
      );

      $(".chat").append(template);
    }

    function chatSetupFailed() {
      let template = $("#new-message").html();
      template = template.replace(
        "{{body}}",
        "<b>Chat Setup Failed. Contact Admin.</b>"
      );

      $(".chat").append(template);
    }

    function activateChatBox() {
      $("#message").removeAttr("disabled");
      $("#btn-chat").click(function() {
        const message = $("#message").val();
        $("#message").val("");

        //send message
        chatChannel.sendMessage(message);
      });

      $("#message").on("keydown", function(e) {
        if (e.keyCode === 13) {
          $("#btn-chat").click();
        }
      });
    }

    

  });

    // Generate random room name if needed

    const roomHash = "usernameddtest";

// TODO: Replace with your own channel ID
const drone = new ScaleDrone("<%= scaledrone %>");

// Room name needs to be prefixed with 'observable-'
const roomName = "observable-" + roomHash;
const configuration = {
  iceServers: [
    { urls: "stun:stun.services.mozilla.com" },
    { urls: "stun:stun.l.google.com:19302" },
    {
      urls: ["<%= stun_url %>"]
    },
    {
      username: "<%= stun_user %>",
      credential: "<%= stun_cred %>",
      urls: [
        "turn:u3.xirsys.com:80?transport=udp",
        "turn:u3.xirsys.com:3478?transport=udp",
        "turn:u3.xirsys.com:80?transport=tcp",
        "turn:u3.xirsys.com:3478?transport=tcp",
        "turns:u3.xirsys.com:443?transport=tcp",
        "turns:u3.xirsys.com:5349?transport=tcp"
      ]
    }
  ]
};
let room;
let pc;

function onSuccess() {}
function onError(error) {
  console.error(error);
}

drone.on("open", error => {
  if (error) {
    return console.error(error);
  }
  room = drone.subscribe(roomName);
  room.on("open", error => {
    if (error) {
      onError(error);
    }
  });
  // We're connected to the room and received an array of 'members'
  // connected to the room (including us). Signaling server is ready.
  room.on("members", members => {
    console.log("MEMBERS", members);
    // If we are the second user to connect to the room we will be creating the offer
    const isOfferer = members.length === 2;
    startWebRTC(isOfferer);
  });
});

// Send signaling data via Scaledrone
function sendMessage(message) {
  drone.publish({
    room: roomName,
    message
  });
}

function startWebRTC(isOfferer) {
  pc = new RTCPeerConnection(configuration);

  // 'onicecandidate' notifies us whenever an ICE agent needs to deliver a
  // message to the other peer through the signaling server
  pc.onicecandidate = event => {
    if (event.candidate) {
      sendMessage({ candidate: event.candidate });
    }
  };

  // If user is offerer let the 'negotiationneeded' event create the offer
  if (isOfferer) {
    pc.onnegotiationneeded = () => {
      pc.createOffer()
        .then(localDescCreated)
        .catch(onError);
    };
  }

  // When a remote stream arrives display it in the #remoteVideo element
  pc.ontrack = event => {
    const stream = event.streams[0];
    if (!remoteVideo.srcObject || remoteVideo.srcObject.id !== stream.id) {
      remoteVideo.srcObject = stream;
    }
  };

  navigator.mediaDevices
    .getUserMedia({
      audio: true,
      video: true
    })
    .then(stream => {
      // Display your local video in #localVideo element
      localVideo.srcObject = stream;
      // Add your stream to be sent to the conneting peer
      stream.getTracks().forEach(track => pc.addTrack(track, stream));
    }, onError);

  // Listen to signaling data from Scaledrone
  room.on("data", (message, client) => {
    // Message was sent by us
    if (client.id === drone.clientId) {
      return;
    }

    if (message.sdp) {
      // This is called after receiving an offer or answer from another peer
      pc.setRemoteDescription(
        new RTCSessionDescription(message.sdp),
        () => {
          // When receiving an offer lets answer it
          if (pc.remoteDescription.type === "offer") {
            pc.createAnswer()
              .then(localDescCreated)
              .catch(onError);
          }
        },
        onError
      );
    } else if (message.candidate) {
      // Add the new ICE candidate to our connections remote description
      pc.addIceCandidate(
        new RTCIceCandidate(message.candidate),
        onSuccess,
        onError
      );
    }
  });
}

function localDescCreated(desc) {
  pc.setLocalDescription(
    desc,
    () => sendMessage({ sdp: pc.localDescription }),
    onError
  );
}
</script>
